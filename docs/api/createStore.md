# `createStore(reducer, [initialState])`

Создает Redux [хранилище](Store.md) которое хранит полное дерево состояния вашего приложения. Оно должно быть единственным хранилищем в вашем приложении.

#### Параметры

  1. `reducer` *(Function)*: [Функция редьюсера](../Glossary.md#reducer) которая возвращает следующее [дерево состояния](../Glossary.md#state), принимая текущее состояние и [действие](../Glossary.md#action) к обработке.

  2. [`initialState`] *(any)*: Начальное состояние. Вы можете дополнительно указать это для гидрирования состояния с сервера в универсальных приложениях или для восстановления предыдущей сериализированной сессии пользователя. Если вы создали `редьюсер` с помощью [` combineReducers`](combineReducers.md) - это должно быть простым объектом с той же формой, как и ключи переданные ему. Иначе, вы можете передать все, что ваш `редьюсер` может понять.

#### Возвращает

([*`Store`*](Store.md)): объект, который содержит полное состояние вашего приложения. Единственный способ изменить его состояние — путем [отправки действий](Store.md#dispatch). Вы можете также [подписаться](Store.md#subscribe) на изменения его состояния, чтобы обновить пользовательский интерфейс.

#### Пример

```js
import { createStore } from 'redux';

function todos(state = [], action) {
  switch (action.type) {
  case 'ADD_TODO':
    return state.concat([action.text]);
  default:
    return state;
  }
}

let store = createStore(todos, ['Use Redux']);

store.dispatch({
  type: 'ADD_TODO',
  text: 'Read the docs'
});

console.log(store.getState());
// ['Use Redux', 'Read the docs']
```

#### Советы

  * Не создавайте более одного хранилища в приложении! Вместо этого используйте [`combineReducers`](combineReducers.md) для создания единого корневого редьюсера из нескольких.

  * Выбор формата состояния на ваше усмотрение. Можно использовать простые объекты или что-то вроде [Immutable](http://facebook.github.io/immutable-js/). Если вы не уверены, начните с простых объектов.

  * Если ваше состояние является простым объектом, убедитесь, что вы никогда его не изменяете! Например, вместо того, чтобы возвращать что-то вроде `Object.assign (state, newData)` из ваших редьюсеров, возвращайте `Object.assign ({}, state, newData)`. Таким образом, не переопределяется предыдущее `состояние`. Вы также можете написать `return { ...state, ...newData }` если вы включите [ES7 object spread proposa](https://github.com/sebmarkbage/ecmascript-rest-spread) с [Babel stage 1](http://babeljs.io/docs/usage/experimental/).

  * Для универсальных приложений, которые выполняются на сервере, создавайте экземпляр хранилища с каждым запросом, так чтобы они были изолированы. Отправляйте несколько извлеченных действий для экземпляра хранилища и ждите их завершения перед рендерингом приложения на сервере.

  * Когда хранилище создано, Redux отправляет фиктивное действие для вашего редьюсера, для заполнения хранилища с начальным состоянием. Вам не надо обрабатывать фиктивное действие напрямую. Просто помните, что ваш редьюсер должен возвращать какое-то начальное состояние, если состояние переданое ему в качестве первого аргумента не `определено (undefined)` и все готово.