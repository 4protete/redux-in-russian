# Мотивация

Требования для одностраничных JavaScript приложений становится все более сложными, **больше состояний(State) нуждаются в управлении** с помощью JavaScript, чем кода либо прежде. Эти состояния могут включать в себя ответы сервера, кэшированные данные и данные, созданные локально, но еще не сохраненные на сервере. Это также относится к UI состояниям, таким как активный путь, выделенный таб или показ счетчика или нумерация страниц и так далее.

Управлять всегда изменяющимися состояниями сложно. Если модель(Model) может обновлять другую модель, тогда представление(View) может обновить модель, которая обновляет другую модель, а это, в свою очередь, может вызвать обновление другого представления. В какой-то момент вы больше не знаете что происходит в вашем приложении. **Вы больше не можете контролировать когда, почему, и как состояние обновилось**. Затем система становится непрозрачной и недетерминированной, трудно выявить ошибки или добавлять новую функциональность.

Это достаточно скверно, принимая во внимание **новые требования становящиеся обычными для фронт энд разработки**, такие как обработка оптимистичных обновлений(optimistic updates), рендер на сервере, извлечение данных перед выполнением перехода на страницу, и так далее. Мы front-end разработчики обнаруживаем себя окруженными сложностями, с которыми мы никогда до этого не сталкивались. [Настало время сдаться?](http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html)

Многие из этих сложностей получаются из-за того, что **мы смешиваем две концепции**, которые очень сложны для понимания: **изменения и асинхронность.** Я называю их [Ментос и Кола](https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption). Обе эти технологии могут быть прекрасными по отдельности, но вместе они превращаются в бардак. Библиотеки, аналогичные [React](http://facebook.github.io/react), пытаются решить эту проблему на уровне представления, удаляя асинхронность и напрямую манипулировать DOM. Однако, React оставляет управление состояними ваших данных вам.ate mutations predictable** by imposing certain restrictions on how and when updates can happen. These restrictions are reflected in the [three principles](ThreePrinciples.md) of Redux.
