# Мотивация

Требования для одностраничных JavaScript приложений становятся все более сложными, **больше состояний (State) нуждаются в управлении** с помощью JavaScript, чем когда либо прежде. Эти состояния могут включать в себя ответы сервера, кэшированные данные и данные созданные локально, но еще не сохраненные на сервере. Это также относится к UI-состояниям, таким как - активный маршрут (route), выделенный таб или показ счетчика или нумерация страниц и т.д.

Управлять постоянно изменяющимися состояниями сложно. Если модель может обновить другую модель, то представление может обновить модель, которая обновляет другую модель, а это, в свою очередь, может вызвать обновление другого представления. В какой-то момент вы больше не знаете что происходит в вашем приложении. **Вы больше не можете контролировать когда, почему, и как состояние обновилось**. Когда система становится непрозрачной и недетерминированной, трудно выявить ошибки или добавлять новую функциональность.

Это достаточно скверно, принимая во внимание **новые требования становящиеся обычными для фронтэнд разработки**, такие как, обработка оптимистичных обновлений (optimistic updates), рендер на сервере, извлечение данных перед выполнением перехода на страницу и так далее. Как frontend разработчики, мы оказываемся в окружении со сложностями, с которыми мы никогда не имели дело с прежде, [настало время сдаться?](http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html)

Многие из этих сложностей возникают из-за того, что **мы смешиваем две концепции**, которые очень сложны для понимания: **изменения (mutation) и асинхронность (asynchronicity).** Я называю их [Ментос и Кола](https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption). Обе эти технологии могут быть прекрасными по отдельности, но вместе они превращаются в бардак. Библиотеки, аналогичные [React](http://facebook.github.io/react), пытаются решить эту проблему на уровне представления, удаляя асинхронность и прямое манипулирование DOM. Тем не менее, React оставляет управление состояними ваших данных вам.

Следуя тропами [Flux](http://facebook.github.io/flux), [CQRS](http://martinfowler.com/bliki/CQRS.html) и [Event Sourcing](http://martinfowler.com/eaaDev/EventSourcing.html), **Redux пытается сделать изменения состояния предсказуемым**, путем введения некоторых ограничений на то, как и когда могут произойти обновления. Эти ограничения отражены в [трех принципах](ThreePrinciples.md) Redux.